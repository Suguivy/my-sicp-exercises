;; a
(define (reduce-terms n d)
  (let ((g (gcd-terms n d))
        (f (expt (coeff (first-term g))
                 (+ (- (max (order (first-term n))
                            (order (first-term d)))
                       (order (first-term g)))
                    1))))
    (let ((new-n (div-terms (map (lambda (term) (make-term (order term)
                                                        (* (coeff term) f)))
                                 n)
                            g))
          (new-d (div-terms (map (lambda (term) (make-term (order term)
                                                           (* (coeff term) f)))
                                 d)
                            g)))
      (let ((new-g (apply gcd (map cadr (append new-n new-d)))))
        (list (map (lambda (term) (make-term (order term)
                                             (/ (coeff term) new-g)))
                   new-n)
              (map (lambda (term) (make-term (order term)
                                             (/ (coeff term) new-g)))
                   new-d))))))

(define (reduce-poly p1 p2)
  (if (same-variable? p1 p2)
      (make-poly (variable p1)
                 (reduce-terms (term-list p1)
                               (term-list p2)))
      (error "Not the same variable: REDUCE-POLY" (list p1 p2))))

;; b
(define (reduce-integers n d)
  (let ((g (gcd n d)))
    (list (/ n g) (/ d g))))

(put 'reduce '(scheme-number scheme-number) reduce-integers)
(put 'reduce '(poly poly) reduce-poly)

(define (reduce a b)
  (apply-generic 'reduce a b))
