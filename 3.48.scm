;; The method described avobe, in effect, avoids deadlock. A situation of deadlock when someone tries to exchange a1 with a2 and another tries to exchange a2 with a1 cannot ever be produced. The deadlock is produced when multiple resources (accounts in this case) are shared at once and a cyclic request of resources is produced (when the proceses are requesting the resources that the other have). With this method, if two `exchange' processes want to use the same accounts, both will pick first the lowest UID level acount, regardless of the "direction" of the exchange. In this particular case, if the same situation is produced, Paul will have to wait until Peter the account with the lowest UID, and deadlock is impossible.

(define (serialized-exchange a1 a2)
  (let ((s1 (a1 'serializer))
        (s2 (a2 'serlalizer)))
    (if (< (a1 'uid) (a2 'uid))
        ((s2 (s1 exchange)) a1 a2)
        ((s1 (s2 exchange)) a1 a2))))

(define make-account-and-serializer
  (let ((next-free-uid 0))
      (lambda (balance)
        (define (withdraw amount)
          (if (>= balance amount)
              (begin (set! balance (- balance amount)) balance)
              "Insufficient funds"))
        (define (deposit amount)
          (set! balance (+ balance amount)) balance)
        (let ((balance-serializer (make-serializer))
              (uid next-free-uid))
          (set! (next-free-uid (+1 next-free-uid)))
          (define (dispatch m)
            (cond ((eq? m 'withdraw) (balance-serializer withdraw))
                  ((eq? m 'deposit) (balance-serializer deposit))
                  ((eq? m 'balance) balance)
                  ((eq? m 'serializer) balance-serializer)
                  ((eq? m 'uid) uid)
                  (else (error "Unknown request: MAKE-ACCOUNT" m))))
          dispatch))))
